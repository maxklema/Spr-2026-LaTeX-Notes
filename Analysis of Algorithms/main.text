\documentclass[11pt]{article}
\usepackage[a4paper,left=2.5cm,right=2.5cm,top=\dimexpr15mm+1.5\baselineskip,bottom=2cm]{geometry}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{fancyhdr} % Headings
\usepackage{listings} % Code
\usepackage{parskip} % Spacing for Paragraphs
\usepackage{mdframed} % Asides
\usepackage{caption}
\usepackage{graphicx}
\usepackage{amsmath}

% Asides
\newenvironment{aside}
  {\begin{mdframed}[style=0,%
      leftline=false,rightline=false,leftmargin=2em,rightmargin=2em,%
          innerleftmargin=0pt,innerrightmargin=0pt,linewidth=0.75pt,%
      skipabove=7pt,skipbelow=7pt]\small}
  {\end{mdframed}}

\renewcommand{\headrulewidth}{.2mm} % header line width

\rhead{\today}
\lhead{\textbf{Maxwell Klema}}
\cfoot{\thepage}


\title{Advanced Database Topics}
\date{Spring 2026, Purdue University Fort Wayne}
\author{Maxwell Klema | Professor Jin Soung Yoo}

\lstset{
    frame=single, % Adds a single line frame around the code
}

\begin{document}

\maketitle
\pagestyle{fancy}

\vspace{11pt}
\section{Lecture 1 - Fundamental Concepts of Database Management}
\vspace{11pt}

\subsection{Applications of Database Technology}
\vspace{11pt}

\textbf{Data in the Real World}
\vspace{11pt}

Data is everywhere, appearing in various forms and sizes. This includes:
\begin{itemize}
    \item Traditional data: Traditional numeric and alphanumeric data in an application
    \item Text data: Documents, emails, and social media posts
    \item Multimedia data: images, audio, and video files
    \item Spatial, temporal data: Geographical, location-based, and time-related information
    \item Volatile data: High-frequency, real-time data
    \item Big Data: large and complex data sets.
\end{itemize}

These data types require effective storage and management using suitable data management techniques.

\vspace{11pt}
\textbf{Applications of Database Technology}
\vspace{11pt}

There are many applications of Database Technology. They can include, but are not limited to: Traditional Business Applications (Structured numeric and alphanumeric data - inventory, payroll, accounting systems), Multimedia Applications (Storage and retrieval of images, audio, and video - e.g,. YouTube, Spotify), Geographical Information Systems (GIS) (Management and analysis of spatial and located-based data - Google Maps), Financial Applications (High-volume, rapidly changing data with strict consistency requirements - like investment banking systems), Sensor-Based Applications (Continuous data streams from sensors - e.g., environmental monitoring, automated shutdown systems), Biometric Applications (Management of biological identifiers - fingerprints, facial or retina scans), Wearable and IoT Applications (Personal and real-time activity data - Fitbit, Apple Watch), Big Data Applications (Large-scale data collection and analytics - retailer point-of-sale and transaction systems).

\vspace{11pt}
\subsection{Key Definitions}
\vspace{11pt}

A Database is a collection of related data organized to support a specific business process or problem domain. A database is designed for a target group of users and the applications that access the data.

A Database Management System (DBMS) is a software system used to define, create, store, manipulate, and maintain a database. A DBMS is composed of multiple software modules, each supporting different database functions.

A Database System is the combination of a database and its DBMS, which often includes database programs/tools and users.

\vspace{11pt}
\subsection{File vs. Database Approach to Data Management}
\vspace{11pt}


\vspace{11pt}
\textbf{File-based Approach to Data Management}
\vspace{11pt}

\begin{center}
    \includegraphics[width=0.5\textwidth]{1.jpg}    
\end{center}

In a file-based approach to data management, each application maintains its own data files, even when storing the same data. An application may access one or multiple files, and data files store only raw data, without metadata or structured definitions.

Data definitions and descriptions are embedded separately within each application, and, as a result, as the number of applications grows, this approach leads to major data management problems.

Here are Seven Problems related to the File-based Approach
\begin{itemize}
    \item Data Redundancy - The same information is stored multiple times across different files.
    \item Data Inconsistency - Duplicate data may become inconsistent when updates are not synchronized.
    \item Strong Application-Data Dependence - Data structure changes require modifications to application programs.
    \item Duplicate Access Logic - Each application defines its own queries and access procedures. Similar procedures are repeatedly implemented across applications.
    \item Poor Maintainability - Systems are difficult to update, manage, and scale over time.
    \item Limited Concurrency Control - Hard to support safe simultaneous access by multiple users.
    \item Difficult Integration - Integrating applications across departments or organizations is challenging.
\end{itemize}

\begin{center}
    \includegraphics[width=0.5\textwidth]{2.jpg}  
\end{center}
\vspace{11pt}

Note: Raw data and Catalog data (metadata, permissions, users, etc.) are a part of the DBMS.

All data is stored and managed centrally by a DBMS, and applications interact directly with the DBMS, not with individual files. The DBMS retrieves and delivers data in response to application requests. 

The DBMS can manage two types of data: Raw data (actual stored data) and Metadata (data definitions and descriptions). Metadata is centrally managed by the DBMS, rather than embedded in applications (Key difference from the file-based approach)

\vspace{11pt}
\textbf{Advantages of Database Approach}
\vspace{11pt}

A database approach is more efficient and reliable than the file-based approach, as there is improved performance, data consistency, and easier maintenance.

There is also increased data independence, where applications are independent of data storage and data definitions. This leads to loose coupling, where applications and data are loosely coupled, making systems easier to modify and extend.

Additionally, with many DBMSs, there are high-level Database Languages provided, such as Structured Query Language (SQL), which is a standardized way to query and manipulate data. With SQL, users specify what they need, not how to retrieve it. SQL queries are executed by the DBMS, hiding low-level retrieval details, leading to transparent execution.

\vspace{11pt}
\textbf{Query Examples}
\vspace{11pt}

In a file-based Approach:

\vspace{11pt}
\begin{lstlisting}[language=SQL]
Procedure FindCustomer;
begin
    open file Customer.txt;
    Read(Customer)
    While not EOF(Customer)
        If Customer.name='Bart then
            display(Customer);
        EndIf
        Read(Customer);
    EndWhile;
End;
\end{lstlisting}
\vspace{11pt}

In a Database Approach (SQL):
\vspace{11pt}
\begin{lstlisting}[language=SQL]
SELECT *
FROM Customer
WHERE name = 'Bart'
\end{lstlisting}
\vspace{11pt}

\vspace{11pt}
\subsection{Elements of a Database System}
\vspace{11pt}

There are many elements of a Database System:
\begin{itemize}
    \item Database Model vs. Database Instances: Distinction between database structure and its current contents.
    \item Data Model: Concepts and rules used to describe data, relationships, and constraints.
    \item Three Layer Architecture: Separation of user views, logical structure, and physical storage.
    \item System Catalog: Metadata repository describing database structure and constraints.
    \item Database Users: Different user roles interacting with the database system.
    \item Database Languages: Languages used to define, query, and manipulate data.
\end{itemize}

\vspace{11pt}
\textbf{What is the Difference between a Database Schema and a Database State (Instance)?}
\vspace{11pt}

A Database Schema (or Model) describes the structure of the database, defines data items, data types, relationships, constraints, and storage details, is defined during database design and changes infrequently, and is stored in the DBMS catalog.

For example, in a Database Schema, it may have a structure such as:

Student(number, name, address, email)

Course (number, name)

Building (number, address)

\vspace{11pt}
Meanwhile, a Database State (Instance) represents the actual data stored in the database at a specific point in time. This is also called a database instance, and it changes frequently as data is inserted, updated, and deleted.

For example, database states (or instances) may be shown as tables with current tuples for STUDENT, COURSE, and BUILDING.

\vspace{11pt}
\begin{aside}
The schema remains relatively stable, while the database state changes over time as records are added, updated, or removed.
\end{aside}
\vspace{11pt}

\vspace{11pt}
\textbf{Data Model}
\vspace{11pt}

A database system uses multiple levels of data models - conceptual, logical, and physical, each describing the data from a different perspective. A well-designed data model is the foundation of a successful database application. A data model provides a clear and precise description of data items, relationships among data, and constraints on the data.

Types of Data Models include Conceptual data models, Logical data models, Internal (Physical) data models, and External data models.

\vspace{11pt}
\textbf{Conceptual Data Model}
\vspace{11pt}

A conceptual data model provides a high-level representation of data items, their characteristics, and relationships. It serves as a communication tool between information architects and business users. It is implementation-independent and focused on business concepts. It is also user-friendly and aligned with how business users view the data.

Conceptual data models are developed through close collaboration between information architects and business users. They are commonly represented using Enhanced Entity-Relationship (EER) models and Object-oriented models.

\vspace{11pt}
\textbf{Logical Data Model}
\vspace{11pt}

A logical data model refines the conceptual data model based on the chosen implementation environment. It maps conceptual concepts to a specific logical data framework, while remaining understandable to business users, while also closer to actual data structures.

A logical data model depends on the database paradigm used, such as Relational, Hierarchical, Object-oriented, Extended relational (object-relational), XML-based, and NoSQL. Logical data models serve as an intermediate step that can be mapped to the internal (physical) data model.

\vspace{11pt}
\textbf{Physical Data Model (Internal Data Models)}
\vspace{11pt}

A physical data model describes the physical storage details of the database. Specifically, it specifies where the data is stored, how the data is formatted on disk, and which indexes and access paths are used.

Physical data models focus on performance and storage efficiency. It is highly specific to the DBMS and underlying storage system.

\vspace{11pt}
\textbf{External Data Model}
\vspace{11pt}

An external data model consists of user-specific views, each representing a subset of the logical data model. A view shows only the data relevant to a particular application or user group (irrelevant data is hidden, simplifying data accesses).

Views are designed to meet the specific needs of applications or user groups. A single view may be used by one or more applications, while supporting access control and data security.

Some examples of views include a student registration application, which accesses a view with student data, while a capacity planning application accesses a view with building data.


\vspace{11pt}
\subsection{Three Layer Architecture for Database Model}
\vspace{11pt}

The three-layer architecture is a fundamental architecture for database systems and defines how different levels of data models interact with each other.

The architecture consists of three layers: External Layer (user-specific views), Conceptual (Logical) Layer (overall logical structure of the database, and the Internal Layer (physical storage details). Changes in one layer should have minimal impact on the other layers. This architecture creates modularity and improves efficiency, maintainability, performance, and security.

\vspace{11pt}
\textbf{Conceptual / Logical Layer}
\vspace{11pt}

Includes conceptual and logical data models. The logical/conceptual layer also describes data items, their characteristics, types, and relationships with each other. This layer is independent of physical DBMS implementation details.

\vspace{11pt}
\textbf{External Layer}
\vspace{11pt}

The external layer consists of external data models, or views, which provide controlled access to selected portions of the logical data model. Views are tailored to specific applications or user groups.

\vspace{11pt}
\textbf{Internal Layer}
\vspace{11pt}

The internal layer contains the internal (physical) data model. It defines how data is physically stored and organized, while also focusing on storage structures and access methods.

\vspace{11pt}
\textbf{Putting the Three-Layers Together}
\vspace{11pt}

\begin{center}
    \includegraphics[width=0.5\textwidth]{3.jpg}    
\end{center}
\vspace{11pt}

This figure shows the three-layer database architecture. The mappings between layers enable logical and physical data independence, meaning changes at one level have minimal impact on the others.

\vspace{11pt}
\textbf{Example in a Procurement Business Process}
\vspace{11pt}

\begin{center}
    \includegraphics[width=0.5\textwidth]{4.jpg}    
\end{center}
\vspace{11pt}

This architecture allows each department to work with relevant data while sharing a consistent underlying database structure.

\vspace{11pt}
\textbf{Catalog (System Catalog \ Data Dictionary)}
\vspace{11pt}

The system catalog is a core component of a DBMS. The catalog stores metadata, or data definitions, about the database. Metadata contains definitions of views (external data models), logical data models, and internal (physical) data models. The system catalog ensures consistency and synchronization across different data models. The system catalog is used by the DBMS to manage, access, and validate data.

\vspace{11pt}
\textbf{Database Users}
\vspace{11pt}

There are many types of database users, each with unique roles.

The information architect designs the conceptual data model and works closely with business users to capture and model data requirements.

The database designer translated the conceptual model into logical and internal data models. They prepare the database design for implementations.

The database administrator (DBA) is responsible for database implementation and operation. They set up the database infrastructure, while continuously monitoring performance, including response time, throughput, and storage usage.

The application developer develops database applications using general-purpose programming languages. They implement application logic and interacts with the DBMS through APIs or embedded SQL.

Lastly, business users use the database applications to perform specific business tasks. They interact with the database indirectly through applications, not through the DBMS itself.

\vspace{11pt}
\textbf{Database Languages}
\vspace{11pt}

Every DBMS provides one or more database languages.

A Data Definition Language (DDL) is used to define database structures. It specifies external, logical, and internal data models, and is typically used by DBAs and application developers.

A Data Manipulation Language (DML) is used to retrieve, insert, delete, and modify data. It can be executed interactively or embedded in a programming language.

Meanwhile, Structured Query Language (SQL) provides a standard language for relational databases. It provides both DDL and DML capabilities.

\vspace{11pt}
\subsection{Advantages of Database Systems and Database Management}
\vspace{11pt}

\vspace{11pt}
\textbf{Data Independence}
\vspace{11pt}

Data independence is the ability to change data definitions with minimal impact on applications.

In physical data independence, applications, views, and the logical data model remain unchanged. Changes are made only to the internal (physical) data model. Examples include file organization, indexing, and storage location.

In logical data independence, applications are minimally affected by changes to the conceptual or logical data model. Changes at the conceptual/logical layer have little impact on external views.

\vspace{11pt}
\textbf{Database Modeling}
\vspace{11pt}

A data model explicitly represents data items, their characteristics, and relationships. A data model may also specify integrity rules and supported operations. Common types of data models include: Hierarchical models, (Enhanced) Entity-Relationship (EER) models, relational models, and object-oriented models.

A conceptual data model captures business data requirements. It is developed in collaboration with business users. The conceptual model is then translated into logical and internal data models. Clear documentation of assumptions and limitations is essential.

\vspace{11pt}
\textbf{Managing Diverse Data Types}
\vspace{11pt}

There are three general categories of data:
\begin{itemize}
    \item Structured Data: Well-defined schema and data types. Examples include student records (ID, name, address, email).
    \item Semi-Structured Data: Partial or flexible structure. Examples include JSON documents, resumes, and web data.
    \item Unstructured Data: No fixed schema. Examples include text documents, images, and videos.
\end{itemize}

Modern DBMSs can store, manage, and query all three types.

\vspace{11pt}
\textbf{Managing Data Redundancy}
\vspace{11pt}

\textbf{Controlled Data Redundancy} means that some data duplication may be intentional, especially in distributed systems, to improve performance.

\textbf{Consistency Management} means that the DBMS provides mechanisms to synchronize replicated data. This ensures data consistency across multiple copies.

\textbf{Automatic Data Correctness}, unlike file-based systems, means that the DBMS automatically enforces data consistency. No manual intervention by users or applications is required.

\vspace{11pt}
\textbf{Specifying Integrity Rules}
\vspace{11pt}

Data integrity rules ensure the correctness and validity of stored data. Meanwhile, syntactical rules define how data is represented and stored. Examples may include customerID that must be an integer, or birthdate that is stored as month, day, and year.

Semantic rules ensure the logical meaning of data. Examples may include customerID to be unique, Account balance must be greater than 0, and a customer cannot be deleted if pending invoices exist. Centralized enforcement means that integrity rules are part of the conceptual and logical data models and are stored in the catalog and enforced by the DBMS, not by applications.

\vspace{11pt}
\textbf{Concurrency Control}
\vspace{11pt}

DBMSs provide built-in support for concurrent and parallel database operations. Multiple users can simultaneously retrieve and update data. Read and write operations may be executed at the same time.

A key concept is a transaction. A transaction is a sequence of read/write operations treated as an atomic unit. Either all operations are executed, or none are. The DBMS ensures data consistency and prevents inconsistencies during concurrent access.

A DBMS must support ACID properties to ensure correct transaction processing.

\begin{itemize}
    \item Atomicity - A transaction is executed entirely or not at all.
    \item Consistency - A transaction moves the database from one valid state to another.
    \item Isolation - Concurrent transactions behave as if executed sequentially.
    \item Durability - Once committed, transaction results are permanently stored, even after failures.
\end{itemize}

\vspace{11pt}
\textbf{Backup and Recovery Facilities}
\vspace{11pt}

Backup and recovery facilities protect the database against data loss caused by hardware failures, network errors, and software bugs. Backup facilities support full backups and incremental backups. Recovery facilities restore the database to a previous consistent state.

\vspace{11pt}
\textbf{Data Security}
\vspace{11pt}

A DBMS enforces data security using access control mechanisms, where users are authenticated through logins and passwords.

Role-based Access Control (RBAC) assigns different permission levels to users. Examples include read-only access and read-write access. Authorization rules are defined per user or role and are stored in the catalog and enforced by the DBMS. An example includes the Vendor Managed Inventory (VMI) systems, which restrict access based on roles.

\vspace{11pt}
\textbf{Performance Utilities}
\vspace{11pt}

Key Performance Indicators (KPIs) include \textbf{response time }(time between issuing a request and receiving a result), \textbf{throughput} (number of transactions processed per unit time), and \textbf{space utilization} (storage used for raw data and metadata).

DBMS Performance Utilities optimize and distribute data storage, tune indexes for faster query execution, optimize queries to improve application performance, and improve buffer and memory management.

\newpage
\vspace{11pt}
\section{Lecture 2 - Architecture and Categorization}
\vspace{11pt}

\subsection{Architecture of a DBMS}
\vspace{11pt}

\begin{center}
    \includegraphics[width=0.8\textwidth]{5.jpg}
    \vspace{11pt}
    \\
    This diagram presents a high-level architecture of a DBMS.
\end{center}

\vspace{11pt}
\subsection{Architecture of a DBMS - Design Principle \& Access Layer}
\vspace{11pt}

The design principle of a DBMS emphasizes separation of concerns between user interaction, query processing, and physical data management.

In the User Access Layer, users and applications interact with the DBMS through DDL statements (schema definitions), Interactive SQL queries, Application programs, and Database tools. All access is mediated by DBMS interfaces, providing data independence and a uniform access mechanism.

\vspace{11pt}
\subsubsection{Architecture of a DBMS: Core Component (Query Processor)}
\vspace{11pt}

The DBMS consists of two main subsystems. The first is the query processor which interprets and executes SQL statements. Its key components include DDL and DML compilers, query parser and a query rewriter, a query optimizer, and a query executor. Essentially, the query processor translates high-level SQL into efficient execution plans.

\vspace{11pt}
\subsubsection{Architecture of a DBMS: Core Component (Storage Manager and Database Storage)}
\vspace{11pt}

The second main subsystem of a DBMS is the storage manager and database storage. The storage manager manages physical data storage and access. Its key components include a transaction manager, buffer manager, lock manager, and recovery manager. The storage manager and database storage ensures concurrency control, efficient memory use, and system reliability. The Database Storage stores raw data, indexes, and system catalog (metadata).

\vspace{11pt}
\subsubsection{Connection and Security Managers}
\vspace{11pt}

The Connect Manager established a database connection (locally or through a network) and verifies logon credentials and provides a connection handle.

Meanwhile, the Security Manager ensures users have appropriate privileges. It manages access controls, including connection permissions and read vs. write access.

\vspace{11pt}
\subsubsection{DDL Compiler}
\vspace{11pt}

The DDL Compiler compiles the data definitions specified in \textbf{Data Definition Language (DDL)}. It performs the following steps:
\begin{itemize}
    \item Parsing: Checks the syntactical correctness of DDL statements.
    \item Translation: Converts data definitions into an internal format and generates errors if required.
    \item Registration: Upon successful compilation, store the data definitions in the database catalog.
\end{itemize}

\vspace{11pt}
\subsubsection{Query Processor Components}
\vspace{11pt}

The \textbf{Query Processor} is a critical component of a DBMS that handles query execution efficiently.

\begin{center}
    \includegraphics[width=0.5\textwidth]{6.jpg}
\end{center}

\vspace{11pt}
\textbf{DML Compiler}
\vspace{11pt}

The DML Compiler compiles \textbf{Data Manipulation Language (DML)} statements, including INSERT, UPDATE, DELETE, and SELECT. If the DML statement is a query, it collaborates with:
\begin{itemize}
    \item Query Parser: Analyzes the query's syntax and structure.
    \item Query Optimizer: Determines the most efficient execution plan.
    \item Query Executor: Runs the query and retrieves the results.
\end{itemize}

\vspace{11pt}
\textbf{Parser and Rewriter}
\vspace{11pt}

The Query Parser converts a query into an internal representation format. It validates the query for syntactical and semantical correctness using the database catalog. It also generates errors if the query is incorrect.

Meanwhile, the Query Rewriter simplifies the query using predefined rules and heuristics. It optimizes the query independently of the current database state. For example, in RDBMS, nested queries may be reformulated or flatted into join queries for better performance.

\vspace{11pt}
\textbf{Optimizer and Executor}
\vspace{11pt}

The Query Optimizer is a crucial component that enhances DBMS performance. It optimizes the query based upon the current database state (e.g., existing indexes). It generates multiple query execution plans and evaluates their cost in terms of number of I/O operations, CPU processing, and execution time. It combines catalog-based estimates with statistical inference to determine the most efficient execution plan.

The Query Executor executes the final execution plan generated by the optimizer. It interacts with the storage manager to retrieve the required data. It ensures the query is processed correctly and returns the desired results.

\vspace{11pt}
\subsection{Storage Manager}
\vspace{11pt}

The \textbf{Storage Manager} manages physical file access and ensures correct and efficient storage of data.

\begin{center}
    \includegraphics[width=0.5\textwidth]{7.jpg}
\end{center}

There are four main components of the Storage Manager:
\begin{itemize}
    \item Transaction Manager: Ensure ACID properties for database transactions.
    \item Buffer Manager: Handles cache memory for efficient data retrieval and minimizes disk I/O.
    \item Lock Manager: Manages concurrency control to prevent conflicts in multi-user environments.
    \item Recovery Manager: Ensures data integrity by handling failures and supporting rollback/recovery mechanisms.
\end{itemize}

\vspace{11pt}
\textbf{Transaction Manager}
\vspace{11pt}

The Transaction Manager supervises the execution of database transactions. \textit{A transaction is a sequence of read/write operations treated as a single unit}. It creates a schedule with interleaved read/write operations for efficient execution.

The transaction manager also ensures ACID properties: Atomicity (All operations complete or none do), Consistency (Preserves database integrity), Isolation (Prevents interference among concurrent transactions), and Durability (Committed results persist after failures). 

The Transaction Manager commits successful transactions and rolls back failed ones.

\vspace{11pt}
\textbf{Buffer Manager}
\vspace{11pt}

The Buffer Manager manages the buffer memory of the DBMS for efficient data retrieval. It caches data intelligently to reduce disk I/O operations. Additionally, it implements smart replacement strategies when the buffer is full. For example, the data locality principle is applied, where recently retrieved data is likely to be accessed again. The Buffer Manager also interacts with lock manager to handle concurrent access safely.

\vspace{11pt}
\textbf{Lock Manager}
\vspace{11pt}

The Lock Manager ensures concurrency control to maintain data integrity at all times. It manages assigning, releasing, and recoridng locks in the catalog. Two types of locks are supported based on data operation type:
\begin{itemize}
    \item Read Lock --- Allow multiple transactions to read simultaneously.
    \item Write Lock --- Ensure exclusive access for modifying data.
\end{itemize}

The Lock Manager uses a locking protocol to define locking rules. It also maintains a lock table to track lock information.

\vspace{11pt}
Recovery Manager
\vspace{11pt}

The Recovery Manager ensures the correct execution of database transactions and maintains database integrity. It maintains a log file to keep track of all database operations. It supports transaction rollback by undoing actions of aborted transactions. Additionally, the Recovery Manager performs crash recovery, ensuring data consistency after system failures.

\vspace{11pt}
\subsubsection{DBMS Utilities}
\vspace{11pt}

Database utility tools improve performance and simplify database maintenance. A \textbf{Loading Utility} facilitates data loading from various sources, including other DBMS systems, text files, Excel files, and other structured/unstructured data formats.

A \textbf{Reorganization Utility} automatically optimizes data storage for better performance. It enhances query efficiency by restricting data organization.

\textbf{Performance Monitoring Utilities} track key performance indicators to monitor DBMS performances, including storage space consumption, query response times, and transactions throughput rates.

\textbf{User Management Utilities} facilitate user and group account management. It supports the assignment of privileges and access control to ensure security.

\textbf{Backup and Recovery Utilities} provide database backup and recovery mechanisms to protect against data loss. It ensures data consistency after system failures or unexpected crashes.

\vspace{11pt}
\subsubsection{DBMS Interfaces}
\vspace{11pt}

To support different user roles, including database designers, administers, applications, and end-users, a DBMS provides multiple user interfaces such as:
\begin{itemize}
    \item Command line interface (CLI)
    \item Graphical user interface (GUI)
    \item Web-based interface
    \item Admin interface
    \item Stand-alone query language interface
    \item Forms-based interface
    \item Natural Langage interface
    \item Network Interface
\end{itemize}

An example of an DBMS Interface is presented in the image below:

\vspace{11pt}
\begin{center}
    \includegraphics[width=0.6\textwidth]{8.png}
\end{center}
\vspace{11pt}

\subsection{Categorization of DBMSs}
\vspace{11pt}

DBMSs can be classified along multiple, largely independent dimensions, reflecting differences in data representation, system architecture, workload, and usage patterns.

\vspace{11pt}
\subsubsection{Categorization by Data Model}
\vspace{11pt}

From a Conceptual/Logical Level:
\begin{itemize}
    \item Hierarchical DBMSs
    \item Network DBMSs
    \item Relational DBMSs
    \item Object-Oriented DBMSs
    \item Object-Relational DBMSs
    \item XML DBMSs
    \item NoSQL DBMSs (key-value, document, column, graph)
\end{itemize}

\newpage
\textbf{Evolution Timeline}
\vspace{11pt}

\begin{table}[ht]
    \centering
    \begin{tabular}{|p{2.2cm}|p{3.5cm}|p{3.5cm}|p{3.5cm}|}
        \hline
        \textbf{Time} & \textbf{Database Technology / Data Management Paradigm} & \textbf{Products} & \textbf{Description} \\ \hline
        1960s--1970s & \textbf{File-based processing} & VMS/VSAM & Managed records, not relationships \\ \hline
        1970s & \textbf{Hierarchical} & IMS, ADABS, IDS-II & Early DBMS with tree-structured data \\ \hline
        1970s & \textbf{Network} & IDS, CODASYL & Navigation-based access \\ \hline
        Mid-1970s -- present & \textbf{Relational} & DB2, Oracle, MS SQL-Server & Conceptual simplicity, ER modeling \\ \hline
        \multirow{2}{2.2cm}{Mid-1980s -- present} & \textbf{Object-oriented} & Versant, Objectivity/DB & \multirow{2}{3.5cm}{Support complex data Extended data types} \\ \cline{2-3}
        & \textbf{Object-relational} & DB2 UDB, Oracle, PostgreSQL & \\ \hline
        Present & \textbf{Semi-structured and complex data models} & dbXML, Tamino, MarkLogic. DB2 UDB, Oracle, PostgreSQL & Support XML and complex data types \\ \hline
        Present & \textbf{NoSQL} & MongoDB, Cassandra, Hbase, Redis, Riak & High scalability and flexible schema \\ \hline
    \end{tabular}
\end{table}

\vspace{11pt}
\subsubsection{Categorization by Degree of Simultaneous Access}
\vspace{11pt}

From a concurrency perspective, there are:
\begin{itemize}
    \item Single-user DBMSs
    \item Multi-user DBMSs
\end{itemize}

This is simple but important for transactions and concurrency control.

\vspace{11pt}
\textbf{Single-User vs. Multi-User Databases}
\vspace{11pt}

Single-User DBMSs allows only one user at a time to interact with the DBMS. This is not suitable for a networked environment where multiple users need simultaneous access.

Multi-User DBMSs support multiple users interacting with the database simultaneously. They are commonly used in distrubyted environments to facilitate concurrent data access.

\begin{center}
    \includegraphics[width=0.5\textwidth]{9.png}

    In this figure, mutliple client requests are handled concurrently by multiple server instances or threads accessing a shared database.
\end{center}

\vspace{11pt}
\subsubsection{Categorization by System Architecture}
\vspace{11pt}
From a Physical/Deployment Perspective:
\begin{itemize}
    \item Centralized DBMSs
    \item Client-Server DBMSs
    \item Distributed DBMSs
    \item Cloud-based DBMSs
\end{itemize}

\vspace{11pt}
\textbf{Centralized DBMS Architecture}
\vspace{11pt}

\begin{center}
    \includegraphics[width=0.5\textwidth]{10.png}
\end{center}

In a Centralized DBMS Architecture, all data is stored and maintained on a centralized server. Users access the database remotely, with all processing happening on the central system.

\vspace{11pt}
\textbf{Client-Server DBMS Architecture}
\vspace{11pt}

\begin{center}
    \includegraphics[width=0.5\textwidth]{11.png}
\end{center}
\vspace{11pt}

In a Client-Server DBMS Architecture, active clients send requests to passive servers, which process database queries. There are two variants:
\begin{itemize}
    \item Fat Server --- Most processing occurs on the server side.
    \item Fat Client --- Clients handle more processing, reducing server load time.
\end{itemize}

\vspace{11pt}
N-Tier DBMS Architecture
\vspace{11pt}

An n-Tier DBMS Architecture consists of multiple layers for scalability and modularity:
\begin{itemize}
    \item Client Layer --- Provides GUI functionality for users.
    \item Application Server --- Hosts business logic and applications.
    \item Database Server --- Runs the DBMS and stores the database
    \item Web Server --- Enables web-based access to the database.
\end{itemize}

For example, here is a three-tiered Client/Server Database Architecture:

\vspace{11pt}
\begin{center}
    \includegraphics[width=0.7\textwidth]{12.png}
    
    \includegraphics[width=0.6\textwidth]{13.png}
\end{center}

\vspace{11pt}
\textbf{Distributed DBMSs}
\vspace{11pt}

A Distributed DBMS manages a single logical database whose data is physically distributed across multiple networked sites. Key features include location transparency and data independence, support for distributed queries and transactions, and data fragmentation and replication across sites.

The benefits of a Distributed DBMS is scalability, availability, and improved performance. However, some challenges include consistency, coordination, and fault tolerance.

\vspace{11pt}
\begin{aside}
    Note: Distributed DBMSs underpin (act as a fundamental foundation) cloud DBMSs, federated DBMSs, and many NoSQL systems.
\end{aside}

\vspace{11pt}
\textbf{Cloud DBMSs}
\vspace{11pt}

Cloud DBMSs are database management systems hosted in the cloud, eliminating the need for on-premise infrastructure. These cloud sites are managed by third-party cloud providers, offering scalability, reliability, and cost-efficiency. Cloud DBMSs supports distributed storage and processing, making it ideal for big data and high-availability applications.

Examples of Cloud DBMSs include Apache Cassandra --- A distributed NoSQL database designed for scalability and fault tolerance. Another is Google Bigtable --- A fully managed, high-performance NoSQL database for large-sale applications.

\vspace{11pt}
\subsubsection{Categorization Based on Usage Workload}
\vspace{11pt}

From a Query and access pattern perspective:
\begin{itemize}
    \item Transaction databases (OLTP)
    \item Analytical databases (OLAP)
    \item Hybrid Transaction/Analytical Processing (HTAP)
\end{itemize}

\vspace{11pt}
\textbf{Transaction Databases}
\vspace{11pt}

\textbf{Online Transaction Processing (OLTP)} Databases focus on managing operational or transactional data. The database server must process a high volume of simple transactions efficiently. The DBMS must have fast response time for short, frequent queries.

\vspace{11pt}
\textbf{Analytical Databases}
\vspace{11pt}

\textbf{Online Analytical processing (OLAP)} Databases use operational data for tactical or strategical decision-making. A limited number of users execute complex queries for business intelligence. The DBMS must efficiently handle complex queries, often in lower frequency.

\vspace{11pt}
\textbf{Hybrid Transaction/Analytical Processing}
\vspace{11pt}

\textbf{Hybrid Transaction/Analytical Processing (HTAP)} systems are designed to support both transactional (OLTP) and analytical (OLAP) workloads on the same database, in near real time.

Key characteristics include a unified data platform for transactions and analytics. HTAPs also eliminates data movement between OLTP and OLAP systems, and it supports real-time or near-real-time analytical queries.

The Benefits of HTAPs include fresh analytics on operational data, simplified system architecture, and reduced data latency and redundancy. Meanwhile, the challenges of HTAPs include balancing performance isolation between OLTP and OLAP and complex concurrency control and query optimization.

\vspace{11pt}
\begin{aside}
    HTAP is increasingly important in modern cloud and in-memory database systems.
\end{aside}

\vspace{11pt}
\subsubsection{DBMSs Span Multiple Dimensions}
\vspace{11pt}

Modern DBMSs cannot be classified using a single criterion.

Example 1: A modern cloud-based NoSQL DBMS may simultaneously be: Non-relational in its data model, distributed in architecture, multi-user, and designed for OLTP or HTAP workloads.

Example 2: NewSQL DBMS is a relational data model, distributed architecture, multi-user, and OLTP-oriented.

The takeaway is that no single taxonomy fully captures modern DBMSs. Real-world systems occupy multiple points in the design space.

\vspace{11pt}
\section{Lecture 3 - Conceptual Data Modeling --- Using UML Class Diagram}
\vspace{11pt}

\subsection{Origin and Recap of Object Orientation}
\vspace{11pt}

\textbf{Origin of UML}
\vspace{11pt}

\textbf{Unified Modeling Language (UML)} is a standardized modeling language for specifying, visualizing, constructing, and documenting software systems. UML was standardized by the Object Management Group (OMG) in 1997 and later approved as an International Organization for Standardization (ISO) standard in 2005. The most recent major version is UML 2.5, released in 2017.

UML includes multiple diagram types: Use cases, sequence, package, deployment, and others. From a database modeling perspective, the class diagram is the most relevant.

\textbf{UML class diagrams} are widely used to represent ER-style concepts --- such as entities, attributes, and relationships in many commercial database design tools.

Here is an example of a UML Class Diagram:
\vspace{11pt}
\begin{center}
    \includegraphics[width=0.65\textwidth]{14.png}
\end{center}

\newpage
\textbf{Recap of Object Orientation}
\vspace{11pt}

A class is a blueprint that defines a set of objects (comparable to an entity type in the ER model). An object is an instance of a class (Comparable to an entity in the ER model). An object is characterized by Variables (attributes) and Methods (operations.

Variables correspond to attribute types, and variable values correspond to attributes in ER. Methods have no direct equivalent in ER models.

For example, there is a Student class. Objects include Bart, Wilfried, and Seppe. Variables include name, gender, and birthdate. Methods include calcAge(), isBirthday(), and hasPassed(courseID).

\textbf{Information Hiding (Encapsulation)} is where object variables are accessed only through getter and setter methods. A \textit{getter} retrieve the value of the variable while a \textit{setter} assigns or updates the value of a variable.

\textbf{Inheritance} is where a superclass can have one or more subclasses. Subclasses inherit both variables and methods from the superclass.

\textbf{Method Overloading} is where multiple methods in the same class may share the same name. Methods are distinguished by different numbers or types of input parameters (method signature).

\vspace{11pt}
\subsection{Classes, Variables, and Access Modifiers}
\vspace{11pt}

\textbf{Classes in UML}
\vspace{11pt}

In a UML class diagram, a class is represented as a rectangle with three sections. The Top is the class name, the middle are variables (attributes), and the bottom are methods (operations).

\vspace{11pt}
\begin{center}
    \includegraphics[width=0.3\textwidth]{15.png}
\end{center}
\vspace{11pt}

\textbf{Variables in UML}
\vspace{11pt}

UML provides primitive data types such as String, Integer, and Boolean. UML also allows user-defined data types (domains).

UML also supports \textbf{Composite variables} and\textbf{ Multi-valued variables}. Composite variables may decompose into components (e.g., first name, last name) or they define and reuse a custom domain (e.g., Name\_Domain). Multi-valued variables use multiplicity to indicate how many values a variable may have for one object. (e.g., email: String [0.. 4], email: String [*] (unbounded)).

\textbf{Derived Variables} are indicated by a leading forward slash (e.g., /age).

\textbf{Variables with Unique Values}: UML does not explicitly model key attributes as in ER. UML assumes an object-oriented DBMS (OODBMS) implementation. 

Each object is assigned a unique, \textbf{Immutable Object Identifier (OID)}. The OID uniquely identifies objects throughout their lifetime. Therefore, no separate key variables are required in UML.

\vspace{11pt}
\begin{center}
    \includegraphics[width=0.3\textwidth]{16.png}
\end{center}

\vspace{11pt}
\textbf{Access Modifiers}
\vspace{11pt}

Access modifiers specify who can access a class's variables or methods. There are three primary access levels:
\begin{itemize}
    \item Private (denoted by '-'): Accessible only within the class.
    \item Public (denoted by '+'): Accessible by any other class.
    \item Protected (denoted by '\#'): Accessible by the class and subclasses.
\end{itemize}

As a general design guideline, it is important to declare all variables as private to support information hiding.

\vspace{11pt}
\textbf{Associations}
\vspace{11pt}

An association in UML corresponds to a relationship type in ER. Multiple associations may exist between the same pair of classes. A specific instance of an association is called a \textbf{link}. Association is also characterized by its multiplicities, which corresponds to cardinalates in ER.

\vspace{11pt}
\begin{center}
\begin{tabular}{|c|c|}
    \hline
    \textbf{UML Multiplicity} & \textbf{ER Cardinality} \\ \hline
    * & 0..N \\ \hline
    0..1 & 0..1 \\ \hline
    1..* & 1..N \\ \hline
    1 & 1..1 \\ \hline
\end{tabular}
\end{center}

\newpage
\textbf{Association Class}
\vspace{11pt}

When an association has its own variables and/or methods, it can be modeled as an association class. An association class represents properties that belong to the relationship itself, not to either class.

\vspace{11pt}
\begin{center}
    \includegraphics[width=0.75\textwidth]{17}
\end{center}

\vspace{11pt}
\textbf{Unidirectional vs. Bidirectional Association}
\vspace{11pt}

Associations may include navigation arrows to indicate direction. The arrow specifies the allowed direction of access or querying.

In a Unidirectional Association, navigation is possible in one directly own and is shown using a single arrow. Meanwhile, in a Bidirectional Association, navigation is possible in both directions and no arrow is shown.

For example, all purchase orders can be retrieved from a supplier object. It is not possible to navigate from a purchase order to its supplier.

\vspace{11pt}
\textbf{Qualified Association}
\vspace{11pt}

A qualified association is a special type of binary association. It uses a qualifier to further restrict or refine the association. The qualifier consists of one or more key variables that index a subset of related objects. The qualifier acts like a key, selecting a specific related object and thereby reducing the effective multiplicity. A qualifier is shown as a small rectangle attached to the association end.

\vspace{11pt}
\begin{center}
    \includegraphics[width=.65\textwidth]{18.png}
\end{center}

In a navigation context, a qualifier is used to select a specific related object from all objects participating in the association. In an implementation context, each qualifier value references a unique target object. When an application requires data retrieval based on search keys, qualified associations are generally appropriate.

For example, in the diagram above, the association \texttt{PLAYS AT} Connects \texttt{Team} and \texttt{Player}. The association is qualified by the attribute \texttt{position}. This qualifier acts a an index or key: Given a team and a position, at most one player is identified.

As a result, the effective multiplicity on the player side is \texttt{0..1}. The small rectangle labeled position visually represents the qualifier.

\vspace{11pt}
\textbf{Qualified Association: ER vs. UML Example}
\vspace{11pt}

ER Model: There exists a 1:N relationship between TEAM and PLAYER. A team can have zero to many players. A player is always related to exactly one team.

UML (Qualified Association): The association is qualified by position. For a given team and position, there are zero or one players. A player still belongs to exactly one team.

\vspace{11pt}
\textbf{Qualified Association for Weak Entity Types}
\vspace{11pt}

Qualified associations in UML can be used to model weak entity types in ER.

\vspace{11pt}
\begin{center}
    \includegraphics[width=0.7\textwidth]{19.png}
\end{center}


ER Model: ROOM is a weak entity that depends on HOTEL. The room number is a partial key, and a room belongs to exactly one hotel.

\vspace{11pt}
\begin{center}
    \includegraphics[width=0.6\textwidth]{20.png}
\end{center}

In the UML model, The association between Hotel and Room is qualified by room number. The qualifier acts as an index (partial key). Essentially, a hotel + room number identifiers zero or one room. Each room always belongs to exactly one hotel.

\vspace{11pt}
\subsection{Specialization and Generalization}
\vspace{11pt}

Similar to the EER model, UML supports specialization and generalization relationships. A superclass represents a general concept, while subclasses represent specialized versions of the superclass.

The symbol is an empty (or filled) triangle that points from the subclass to the superclass. UML allows specialization constraints such as total/partial and disjoint/overlapping.

\vspace{11pt}
\begin{center}
    \includegraphics[width=0.5\textwidth]{21.png}
\end{center}
\vspace{11pt}

Another example is included in the UML diagram below:

\vspace{11pt}
\begin{center}
    \includegraphics[width=0.75\textwidth]{22.png}
\end{center}


\vspace{11pt}
\textbf{Aggregation}
\vspace{11pt}

Aggregation represents a whole-part (composite-part) relationship between classes. The composite class is made up of two types of aggregation: Shared aggregation (aggregation) and composite aggregation (composition).

\vspace{11pt}
\begin{center}
    \includegraphics[width=0.6\textwidth]{23.png}
\end{center}

\vspace{11pt}
\textbf{Shared Aggregation (Aggregation)}
\vspace{11pt}

A part object may belong to multiple composite objects. The maximum multiplicity at the composite side is not fixed.\textbf{ A part object may exist independently of any composite}. This represents a loose coupling between the composite and part classes.

For example, a consultant may work for multiple companies. When a company is removed, its consultants remain in the database.

\vspace{11pt}
\textbf{Composite Aggregation (Composition)}
\vspace{11pt}

A part object can belong to only one composite. The maximum multiplicity at the composite side is 1. The minimum multiplicity may be 0 or 1.\textbf{ This represents a tight coupling between the composite and part classes}. When the composite object is removed, all associated part objects are also removed.

For example, Engine---Car, Engine---Boat. An Account belongs to exactly one Bank. \textit{Thus, removing the bank removes all associated accounts}.

\vspace{11pt}
\subsection{Changeability Property}
\vspace{11pt}

The changeability property specifies the type of operations that are allowed on either variable values or links.

There are three common choices:
\begin{itemize}
    \item default --- allows any type of edit
    \item addOnly --- only allows additional values or links to be added (no deletions)
    \item frozen --- allows no further changes once the value or link is established
\end{itemize}

\vspace{11pt}
\begin{center}
    \includegraphics[width=0.6\textwidth]{24.jpg}
\end{center}

\newpage

For example, the frozen property on the supplier number and the purchase order number specifies that once a value is assigned, it cannot be changed.

The language variable of the SUPPLIER class represents the set of languages the supplier can understand. It is defined as addOnly, meaning languages may be added but not removed. 

\textbf{The addOnly property on the ON\_ORDER association} specifies that, for a given supplier, purchase orders can be added but not deleted.


\vspace{11pt}
\textbf{Object Constraint Language (OCL)}
\vspace{11pt}

Object Constraint Language (OCL) is used to specify constraints in UML models. OCL constraints are declarative, meaning they specify what must be true rather than how it is enforced. Additionally, OCL contains no control flow or procedural code.

Typical uses of OCL include
\begin{itemize}
    \item Class invariants
    \item Preconditions and postconditions for methods
    \item Navigation across associations
    \item Constraints on operations and attributes
\end{itemize}
\vspace{11pt}

OCL is standardized by the Object Management Group (OMG)

\vspace{11pt}
\textbf{OCL: Class Invariant and Pre/Post Conditions}
\vspace{11pt}

Class Invariant --- a class invariant is a constraint that must hold for \textbf{all objects} of a class. For example, SUPPLIER: SUPSTATUS > 100 (The status of every supplier must be greater than 100).

Preconditions and Postconditions --- Preconditions must be true before a method is executed, while postconditions must be true after the method completes. For example, (Pre) before withdrawal, the balance must be positive. For Post, after withdrawal, the balance must still be positive.

\vspace{11pt}
\begin{center}
    \includegraphics[width=0.6\textwidth]{25.jpg}

    This image shows two associations: Which employee works in which department and which employee manages which department.
\end{center}
\vspace{11pt}

An example constraint for the UML diagram above is that a manager of a department must have at least 10 years of employment.

\newpage
\begin{lstlisting}
    Context: Department
    inv: self.managed_by.yearsemployed > 10
\end{lstlisting}
\vspace{11pt}

The context of the constraint is the DEPARTMENT class. The keyword \textbf{inv} defines a class invariant. The self keyword refers to a DEPARTMENT object. The role name \textbf{managed\_by} is used to navigate to the \textbf{EMPLOYEE}. The attribute \textbf{yearsemployed} is then evaluated.
\vspace{11pt}

Example Constraint \#2: A department should have at least 20 employees.

\begin{lstlisting}
    Context: Department
    Invariant: self.workers->size() >= 20
\end{lstlisting}
\vspace{11pt}

The context is the DEPARTMENT class. self.workers navigates to the set of employees working in the department. The size() operation computes the number of examples.
\vspace{11pt}

Example Constraint \#3: A manager of a department must also work in that department.

\begin{lstlisting}
    Context: Department
    Invariant: self.managed_by_works_in = self
\end{lstlisting}
\vspace{11pt}

\textbf{Dependency Relationship}
\vspace{11pt}

\begin{center}
    \includegraphics[width=0.6\textwidth]{26.jpg}
\end{center}
\vspace{11pt}

In UML, dependency defines a \textbf{"using"} relationship. Changes in one element may affect another element that depends on it.

Dependencies are shown using \textbf{dashed arrows} in UML. A dependency exists when one class uses another class temporarily and/or the used object is not stored as a member variable.

For example, the EMPLOYEE class defines a method \texttt{tookCourse(CNR)}. This method uses a \texttt{Course} object to check course information. Since the \texttt{COURSE} object is used only within the method, a dependency exists between \texttt{EMPLOYEE} and \texttt{COURSE}.

\vspace{11pt}
\textbf{Association vs. Dependency (Conceptual Difference)}
\vspace{11pt}

Association --- Represents a structural, long-term relationship between classes. Object are linked persistently and one object typically stores a reference to the other. Associations exist independently of method execution and are shown as a solid line. For example, a Department has Employees.

Dependency --- Represents a temporary "uses" relationship between classes. One object uses another within a method. No stored reference is maintained. A dependency only exists during method execution. Dependencies are shown as a dashed arrow in UML. An example is an Employee temporarily using a Course object.

\vspace{11pt}
\begin{center}
    \begin{tabular}{|c|c|c|}
        \hline
        Aspect & Association & Dependency \\ \hline
         Relationship Strength & Strong & Weak \\ \hline
         Lifetime & Long-term & Temporary \\ \hline
         Store references & Yes & No \\ \hline
         UML notion & Solid line & dashed line \\ \hline
    \end{tabular}
\end{center}
\vspace{11pt}

From a database perspective, Associations often map to foreign keys or relationship tables. This affects the database schema design. Meanwhile, dependencies do not usually affect database schema and reflect application logic, not data structure.

\vspace{11pt}
\subsection{UML Class Diagram vs. EER}
\vspace{11pt}

\begin{center}
    \begin{tabular}{|c|c|}
        \hline
        UML Class Diagram & EER Model \\ \hline
         Class & Entity Type \\ \hline
         Object & Entity \\ \hline
         Variable & Attribute Type \\ \hline
         Variable value & Attribute \\ \hline
         Method & --- \\ \hline
         Association & Relationship type \\ \hline
         Link & Relationship \\ \hline
    \end{tabular}
\end{center}
\vspace{11pt}

% in your document body:

\begin{center}
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{UML class diagram} & \textbf{EER model} \\ \hline
        
        Qualified Association & Weak entity type \\ \hline
        
        Specialization/Generalization & Specialization/Generalization \\ \hline
        
        Aggregation & Aggregation (Composite/Shared) \\ \hline
        
        OCL & --- \\ \hline
        
        \multicolumn{1}{|l|}{\textbf{Multiplicity}} & \multicolumn{1}{l|}{\textbf{Cardinality}} \\ \hline
        
        *      & 0..N \\ \hline
        0..1   & 0..1 \\ \hline
        1..*   & 1..N \\ \hline
        1      & 1..1 \\ \hline
    
    \end{tabular}
\end{center}



















\end{document}

